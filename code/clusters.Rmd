---
title: "clusters "
output: html_document
date: "2023-01-18"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# this code will use the stats::kmeans() algorithm to identify clusters appearing in 
# weekly crab spider counts.

```



```{r cluster-intro}

library(ggplot2)
library(gridExtra)

library(dplyr)

setwd("/Users/rcphelps/code/thesis/journalArticle/arXiv-preprint/code")

# source("./code/k-means.R")


source.url <- c("https://raw.githubusercontent.com/cordphelps/ampelos/master/data/bugs.csv")
bugs.tibl <- as_tibble(read.csv(source.url, header=TRUE, row.names=NULL) )

# remove all bugs except clab spider
bugs.tibl <- bugs.tibl %>% 
  dplyr::select(-Agapostemon.sp....green..native.bee., -Bombus.californicus..bumble., -Braconid.wasp, -checkerspot.butterfly, -Diabrotica.undecimpunctata..Cucumber.Beetle., -Diptera..Agromyzidae..leafminer.., -Halictus.sp....3.part..native.bee., -Honey.Bee, -ladyBug, -Lygus.hesperus..western.tarnished.plant.bug., -Orius..pirate.bug., -Osmia.sp...native.bee., -other, -pencilBug, -pentamonidae...stinkBug., -Pyralidae..Snout.Moth., -spider.other) 



```

```{r}


	
	# 11 *unique* weeks are expected to satisfy the design of kmPlotNew()
	weeks.list <- getWeeks(bugs.tibl)


	
	whichData <- bugs.tibl
	# two transects : 'control' and 'oakMargin' (= semi-natural habitat / SNH)
	whichTransect <- 'oakMargin'
	# two trap collection time periods : 'am' and 'pm'
	whichTime <- 'xm'

	clusters.list <- list()
	clusters.tibl <- tibble::tibble('defaultColumn', .rows = 10)
	
		for (i in 1:length(weeks.list)) {

			  # currentWeek <- weeks.list[[i]]
        temp.tibl <- assignClusters(week=weeks.list[[i]], transect = whichTransect,
                                 time=whichTime, tibble=whichData, debug=TRUE)

        clusters.tibl <- dplyr::bind_cols(clusters.tibl, temp.tibl)
                                          
		  }
	
	# cleanup
	# set cluster integers to 'factors' so that ggplot
	# 'fill' will be determined by the integer value
	clusters.tibl <- clusters.tibl %>%
	                 dplyr::select(-'"defaultColumn"') %>%
	                 dplyr::mutate_all(as.factor) %>%
	                 dplyr::mutate(position=row_number()) 
	

  
	kmPlotNew(tibble = clusters.tibl, transectText = whichTransect, timeText = whichTime)
	  
```


```{r}


kmPlotNew <- function(tibble, transectText, timeText) {

	# build a plot that represents weekly clusters (1:3) by vineyard 
  # position (1:10)
  #
  # this result will be used to assess cluster position 'boundaries' 
  # that may appear as samples are taken from the vineyard edge 
  #
  # tibble : columns are "week23" "week24" ... "week32" and "position"
  #          rows are weekly cluster assignments as factors (1:3) 
  #          and row position as character (1:10) (there are 10 rows)
  #
  # weeks : a list, chr[1:10] "week23" "week24" ... "week34"
  # transectText :  text for informational subtitle content
  # time : text for informational subtitle content indicating 'am' or 'pm'
  
  if (transectText == 'oakMargin') {
    # adjust for source data ambiguity
    transectText <- 'SNH'
  }
  
  captionText <- paste("crab spider clusters\n", 
                       "transect: ", transectText, "\ndaytime: ", timeText, sep="")
  
  # get a list of the week labels ('weekXX')
  weeks <- colnames(tibble)
  # get a list of week IDs ('integers')
  weekID.list <- disectWeeks(w=weeks)
  
  
  clusterColors = c("3" = "blue", "2" = "green", "1" = "red", "0" = '#FFFFFF')

	ggplot(data = tibble) + 

  	geom_point(aes(y = position, x = weeks[[1]], fill = week23),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[2]], fill = week24),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[3]], fill = week25),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[4]], fill = week26),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[5]], fill = week27),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[6]], fill = week28),  
  		         shape = 21, size=5) +
	  
  	geom_point(aes(y = position, x = weeks[[7]], fill = week29),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[8]], fill = week30),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[9]], fill = week31),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[10]], fill = week32),  
  		         shape = 21, size=5) +
	  
	  geom_point(aes(y = position, x = weeks[[11]], fill = week34),  
  		         shape = 21, size=5) +

	  scale_fill_manual(values = clusterColors, 
	                    limits = names(clusterColors),
	                    labels = c("cluster 3", "cluster 2", "cluster 1")) +
	
    expand_limits(y=c(1,10)) +
    scale_y_continuous(breaks = seq(min(1), max(10), by = 1)) +
	  
	  scale_x_discrete(breaks=weeks, labels=weekID.list) +
    #expand_limits(x=c(22,34)) +    # enlarge the range of the axis
    #scale_x_discrete(breaks=seq(22,34,2)) +         # log, square-root, reverse....

    geom_hline(yintercept=5.5) +
    geom_hline(yintercept=8.5) +

    coord_fixed(ratio=1) + # control the aspect ratio

    labs(x="week number", y="trap position", caption = captionText ) +

  	theme_bw() +
    
	  # axis.title.x=element_text(angle=45, vjust=0.5),
	  # axis.text = element_text(colour = 1, size = 12),
	  #     legend.spacing.y = unit(0, "mm"), 
	  #     legend.title = element_blank(),
    #     legend.justification=c(1,0),
    #     legend.background = element_blank(),
    #     legend.box.background = element_rect(colour = "black")
    #     guide_legend(title="clusters") +
    #     guides(fill=guide_legend(title="clusters")) +
	  #     aspect.ratio = 1, 
	  
    theme(
          axis.text.x = element_text(angle = 45),
          panel.border = element_rect(colour = "black", fill=NA),
          legend.position="bottom",
          legend.title = element_blank()
          ) 

}

```



```{r cluster-functions}

getWeeks <- function(data) {
  
  # get a vector of weeks found in the tibble of bugs
  
	weeks.vector <- data %>%
   					select(week) %>%
   					unique() %>%
   					.$week

  return(weeks.vector)
	
}

disectWeeks <- function(w) {
  
  # get a vector of weeks by chopping the list of week labels
  # 
  
  weeks.vector <- list()

		for (i in 1:length(w)) {

		  currentWeek <- substring(w[[i]], 5, 6)
      weeks.vector[[i]] <- currentWeek
                               
		  }

  return(weeks.vector)
	
}

enoughData <- function(tibble, debug) {
  
  # check to see if there is enough data (non-zero spider counts)
  # to assign 3 clusters with kmeans() 
  
  # tibble input: for a specific week, spider counts for each positionX
  #
  #  week   positionX   crabSpiders
  
  
  
#             non-zero (of 11) weekly positional spider counts
#           (if count < 2,  clusters of 3 cannot be generated)
#
#  week  'oakMargin'+'am'  'oakMargin'+'pm' 'control'+'am' 'control'+'pm'
#         
#   23         5               10                8             11
#   24        11               11               11             11
#   25         9                9               10             10
#   26         9                9                7              9        
#   27         6                6                4              5
#   28         9               10                7              8
#   29         6                9                8              6
#   30         6                4                7              8
#   31         4                6                7              4
#   32         3                6                5              4
#   34         1                2                2              4

# code to generate the table above (this is the template for enoughData() )
if (FALSE) {
  zero.tibl <- bugs.tibl %>%
    dplyr::filter(transect=='oakMargin')  %>%
    dplyr::filter(time=='am') %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::group_by(week, positionX) %>%
    dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep')

  nonZeroPositions <- list()
  for (i in 1:length(weeks.list)) {
     zeroPositions <- zero.tibl %>% 
      filter(week==weeks.list[[i]] & crabSpiders == 0) %>% nrow()
    nonZeroPositions[[i]] <- 11 - zeroPositions
  }
  print(nonZeroPositions)
}
  
    zeroCounts <- tibble %>% filter(crabSpiders == 0) %>% nrow()

    if (zeroCounts > 9) {
      return(FALSE)
    }
    else {
      return(TRUE)
    }
}

assignClusters <- function(week, transect, time, tibble, debug) {
  
  # rationalize cluster assignments by week such that clusters
  # across multiple weeks can be visually compared
  
  # params :
  # week (discovered by utility function getWeeks()), 
  # transect (either 'control' or 'oakMargin')
  # time (either 'am' or 'pm')
  # tibl : this is the raw (all weeks, both clusters) tibble of all crab spiders
  # debug : (TRUE or FALSE for manual cluster list examination)
  
  # return: a list of 10 integers; values 1, 2, or 3 representing
  # updated cluster assignments
  
  # testing
  # > testParams(week=28, transect='control', tibl=bugs.tibl, debug=TRUE)
  # [1] "original clusters : 3 3 3 3 3 1 1 2 1 1"
  # [1] "revised clusters : 1 1 1 1 1 2 2 2 3 3"
  
  # based on examination of the spider counts for the season
  # I propose that there are 3 distinct clusters each week
  #
  # for positions 1-2-3 (expected typical cluster ID is '1')
  # and for positions 8-9-10 (expected typical cluster ID is '3')
  # kmeans() won't guarantee that they are structured this way,
  # (3s or 2s could be assigned at the beginning, and 1s or 2s at the end.)
  # this function tries to normalize these vectors so patterns 
  # between weeks can be compared.
  
  # kmeans() wants to evaluate groups of points specified in x,y coordinates
  # and assign them to clusters. 
  
  # the kmeans() return object encapsulates numerous params including 
  # 'cluster' (an arbitrary ID) ranked high-to-low or low-to-high.
  # so, to compare clusters across weeks, we need to re-assign cluster IDs
  # based on consistent ranks.
  
  # logic to enable cluster comparison across weeks:
  #
  # check cluster assignments for positions 1-2-3,  4-5-6, 8-9-10
  # I propose that positions 1-2-3 will likely be in the same cluster
  # as will positions 8-9-10. for a week's clusters assigned by kmeans() like                             
  # position              1 2 3 4 5 6 7 8 9 10
  # cluster assignment    3 1 1 x x x x 1 2 2
  
  # this function should notice that 3's should be 2's
  # and vice versa. It does not matter that the ranking criteria 'match' or 
  # 'align' from one week to another. Organizing ranks such that '1s' tend to be
  # at the beginning of the vineyard row and '3s' tend to be at the end of
  # the row will make a graphical comparison of clusters across weeks
  # easier 
  
  # for positions 1-2-3 (expected typical cluster ID is '1')
  # if "no matches" then no cluster assignment changes
  # if at least 2 matches of '1', then no cluster assignment changes
  # if at least 2 matches of '3', 
  #                             change every instance (for all positions) of '3' to '1', 
  #                             change every previous instance of '1' to '3'
  # if at least 2 matches of '2', 
  #                             change every instance (for all positions) of '2' to '1', 
  #                             change every previous instance of '1' to '2'
  # 
  # for positions 8-9-10 (expected typical cluster ID is '3')
  # if "no matches" then no cluster assignment changes
  # if at least 2 matches of '3', then no cluster assignment changes
  # if at least 2 matches of '2', 
  #                             change every instance (for all positions) of '2' to '3', 
  #                             change every previous instance of '3' to '2'
  # if at least 2 matches of '1', then no changes (this probably means that the clusters 
  # are totally scrambled)
  # 
  # note that this logic breaks if the true cluster for both groups 1-2-3 and 
  # 8-9-10 is '1' or '3' (very unlikely)
  # also, it does not correct 
  # position              1 2 3 4 5 6 7 8 9 10
  # cluster assignment    2 2 2 1 1 1 1 3 3 3
  # (this outcome is possible.....)

  # allow all data to be specified
  if (time == 'am' | time == 'pm') {
    bugsByWeek.tibl <- tibble %>%
      dplyr::filter(transect=={{transect}})  %>%
      dplyr::filter(time=={{time}}) %>%
      dplyr::select(-transect, -position, -date, -time, -julian) %>%
      dplyr::group_by(week, positionX) %>%
      dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep'  )
  }
  else {
    bugsByWeek.tibl <- tibble %>%
      dplyr::filter(transect=={{transect}})  %>%
      dplyr::select(-transect, -position, -date, -time, -julian) %>%
      dplyr::group_by(week, positionX) %>%
      dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep'  )
  }
  
  if (FALSE) {
  bugs.tibl %>%
    dplyr::filter(transect=='control')  %>%
    dplyr::filter(time=='pm') %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::group_by(week, positionX) %>%
    dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep')
  }

  # the result is, for each positionX in each week, crabSpider counts are   calculated
  #
  #  week   positionX   crabSpiders

  # isolate the week's data
  week.tibl <- bugsByWeek.tibl %>%
                  dplyr::filter(week=={{week}}) %>%
                  ungroup() %>% dplyr::select(-week)
  
  # verify that there is enough data to make 3 clusters
  if (enoughData(tibble=week.tibl, debug=debug) == TRUE) {
    
    # build the clusters
  
    # note: base::scale() is used to ensure that the original x (spider counts)
    # and y (trap position) axis scales do not skew the cluster assessment
    scaled.tibl <- as_tibble(scale(week.tibl))

    set.seed(20)

    clusters.kmeans <- scaled.tibl %>% 
      dplyr::select(positionX, crabSpiders) %>% 
      kmeans(centers = 3, iter.max = 500, nstart = 3)


    # get the cluster vector
    original.cluster.list <- clusters.kmeans$cluster

    # create lists capturing the original positions of 1, 2, and 3
    ones.list <- replace(original.cluster.list, original.cluster.list != 1, 0)
    twos.list <- replace(original.cluster.list, original.cluster.list != 2, 0)
    threes.list <- replace(original.cluster.list, original.cluster.list != 3, 0)
    # ones.list + twos.list + threes.list = original.scan.list
    orig.ones.list <- ones.list
    orig.twos.list <- twos.list
    orig.threes.list <- threes.list

    # are there at least 2 matches of '3' in position 1-2-3 ?
    if (sum(orig.threes.list[1:3]) > 3) {
      # there are multiple 3s in the first 3 positions, swap 3s to all 1s
      ones.list <- replace(orig.threes.list, orig.threes.list==3, 1)
      twos.list <- replace(orig.twos.list, orig.twos.list==2, 2)
      threes.list <- replace(orig.ones.list, orig.ones.list==1, 3)
    # are there at least 2 matches of '2' in position 1-2-3 ?  
    } else if (sum(orig.twos.list[1:3] == 2) > 2) {
      # there are multiple 2s in the first 3 positions, change all 2s to 1s
      ones.list <- replace(orig.twos.list, orig.twos.list==2, 1)
      twos.list <- replace(orig.ones.list, orig.ones.list==1, 2)
      threes.list <- replace(orig.threes.list, orig.threes.list==3, 3)
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    revised.ones.list <- ones.list
    revised.twos.list <- twos.list
    revised.threes.list <- threes.list

    if (debug==TRUE) {
      print("original")
      print(orig.ones.list)
      print(orig.twos.list)
      print(orig.threes.list)
      print(original.cluster.list)

      print("before 8:10")
      print(" ")
      print(revised.ones.list)
      print(revised.twos.list)
      print(revised.threes.list)
      print(revised.scan.list)
    }

  
    # are there at least 2 matches of '2' in position 8-9-10 ?
    if (sum(revised.twos.list[8:10]) > 2) {
      # there are multiple 2s in the last 3 positions, swap 2s to all 3s
      twos.list <- replace(revised.threes.list, revised.threes.list==3, 2)
      threes.list <- replace(revised.twos.list, revised.twos.list==2, 3)
      ones.list <- replace(revised.ones.list, revised.ones.list==1, 1)
    # are there at least 2 matches of '1' in position 8-9-10 ?  
    } else if (sum(revised.ones.list[8:10]) > 1) {
      # there are multiple 1s in the last 3 positions, change all 1s to 3s
      threes.list <- replace(revised.ones.list, revised.ones.list==1, 3)
      twos.list <- replace(revised.twos.list, revised.twos.list==2, 2)
      ones.list <- replace(revised.threes.list, revised.threes.list==3, 1)
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    revised.ones.list <- ones.list
    revised.twos.list <- twos.list
    revised.threes.list <- threes.list
  
    if (debug==TRUE) {
      print("after 8:10")
      print(" ")
      print(ones.list)
      print(twos.list)
      print(threes.list)
      print(revised.scan.list)
    }
  
    # two final rules
    # position 1 should always be assigned to cluster 1
    # position 10 should always be assigned to cluster 3
    # handling only the situation where a 2 exists in either position
    # (not both)
  
    # is there a '2' in position 1 ?
    if (revised.scan.list[1] == 2) {
      # change all 2s to 1s and 1s to 2s
      ones.list <- replace(revised.twos.list, revised.twos.list==2, 1)
      twos.list <- replace(revised.ones.list, revised.ones.list==1, 2) 
      threes.list <- revised.threes.list
    } 
    # is there a '2' in position 10 ? 
    if (revised.scan.list[10] == 2) {
     # change all 2s to 3s and 3s to 2s
      threes.list <- replace(revised.twos.list, revised.twos.list==2, 3)
      twos.list <- replace(revised.threes.list, revised.threes.list==3, 2) 
      ones.list <- revised.ones.list
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    
  }
  else {
    # enoughData() returned FALSE, not enough data to build clusters
    # set the revised scan list to zeros (no clusters assigned)
    original.cluster.list <- c(0,0,0,0,0,0,0,0,0,0)
    revised.scan.list <- c(0,0,0,0,0,0,0,0,0,0)
  }
  
  if (debug==TRUE) {
      print(paste("week : ", week, sep=''))
      printString <- paste("original clusters : ",
                         do.call("paste",
                                as.list(original.cluster.list)), sep='')
      print(printString)
      printString <- paste("revised clusters : ", 
                         do.call("paste", 
                                 as.list(revised.scan.list)), sep='')
      print(printString)
    }
  

  # return the cluster assignments as a single column tibble
  #
  revised.scan.list.tibl <- as_tibble(revised.scan.list)
  # default column name is 'value'
  # this is a dplyr hack to specify the column name
  # https://stackoverflow.com/questions/45472480/how-to-rename-a-column-to-a-variable-name-in-a-tidyverse-way
  colName <- as.name(paste("week", week, sep=''))
  revised.scan.list.tibl <- revised.scan.list.tibl %>%
                              dplyr::rename(!!colName := value)
  
  return(revised.scan.list.tibl)

}
	
```

