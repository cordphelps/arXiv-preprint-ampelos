---
title: "clusters "
output: html_document
date: "2023-01-18"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# this code will use the stats::kmeans() algorithm to identify clusters appearing in 
# weekly crab spider counts.

```



```{r intro}

library(ggplot2)
library(gridExtra)

library(dplyr)

setwd("/Users/rcphelps/code/thesis/journalArticle/arXiv-preprint/code")

# source("./code/k-means.R")


source.url <- c("https://raw.githubusercontent.com/cordphelps/ampelos/master/data/bugs.csv")
bugs.tibl <- as_tibble(read.csv(source.url, header=TRUE, row.names=NULL) )

# remove all bugs except clab spider
bugs.tibl <- bugs.tibl %>% 
  dplyr::select(-Agapostemon.sp....green..native.bee., -Bombus.californicus..bumble., -Braconid.wasp, -checkerspot.butterfly, -Diabrotica.undecimpunctata..Cucumber.Beetle., -Diptera..Agromyzidae..leafminer.., -Halictus.sp....3.part..native.bee., -Honey.Bee, -ladyBug, -Lygus.hesperus..western.tarnished.plant.bug., -Orius..pirate.bug., -Osmia.sp...native.bee., -other, -pencilBug, -pentamonidae...stinkBug., -Pyralidae..Snout.Moth., -spider.other) 



```


```{r mann-whitney-u-test}


	# 11 *unique* weeks are expected to satisfy the design of kmPlotNew()
	weeks.list <- getWeeks(bugs.tibl)

  positions.group.1 <- c(1, 2, 3)
  positions.group.2 <- c(4, 5, 6, 7)
  positions.group.3 <- c(8, 9, 10)

	whichData <- bugs.tibl
	# two transects : 'control' and 'oakMargin' (= semi-natural habitat / SNH)
	whichTransect <- 'oakMargin'
	# two trap collection time periods : 'am' and 'pm'
	whichTime <- 'pm'

  SNH.group.1.tibl <- whichData %>%
    dplyr::filter(transect==whichTransect)  %>%
    dplyr::filter(time==whichTime) %>%
    dplyr::select(-positionX, -date, -time, -julian) %>%
    dplyr::rename(crabSpiders = Thomisidae..crab.spider.) %>%
    dplyr::group_by(week, position) %>%
    dplyr::summarize(crabSpiders=sum(crabSpiders), .groups='drop'  ) %>%
    dplyr::filter(position %in% positions.group.1) %>%
    dplyr::mutate(transect=whichTransect)


  whichTransect <- 'control'
  
  control.group.1.tibl <- whichData %>%
    dplyr::filter(transect==whichTransect)  %>%
    dplyr::filter(time==whichTime) %>%
    dplyr::select(-transect, -positionX, -date, -time, -julian) %>%
    dplyr::rename(crabSpiders = Thomisidae..crab.spider.) %>%
    dplyr::group_by(week, position) %>%
    dplyr::summarize(crabSpiders=sum(crabSpiders), .groups='drop'  ) %>%
    dplyr::filter(position %in% positions.group.1) %>%
    dplyr::mutate(transect=whichTransect)
  
  #
  #
  #
  # attempting to mirror https://stat-methods.com/home/mann-whitney-u-r/
  # append one tibble to the other
  
library("gmodels")
library("car")
library("DescTools")
library("ggplot2")
library("qqplotr")
library("dplyr")
  
  merged.tibl <- dplyr::bind_rows(control.group.1.tibl, SNH.group.1.tibl) %>%
    dplyr::rename(bugs = crabSpiders) %>%
    dplyr::rename(spray = transect)
  
  merged.tibl %>% 
    select(spray, bugs) %>% 
    group_by(spray) %>% 
    summarise(n = n(), 
            mean = mean(bugs, na.rm = TRUE), 
            sd = sd(bugs, na.rm = TRUE),
            stderr = sd/sqrt(n),
            LCL = mean - qt(1 - (0.05 / 2), n - 1) * stderr,
            UCL = mean + qt(1 - (0.05 / 2), n - 1) * stderr,
            median = median(bugs, na.rm = TRUE),
            min = min(bugs, na.rm = TRUE), 
            max = max(bugs, na.rm = TRUE),
            IQR = IQR(bugs, na.rm = TRUE),
            LCLmed = MedianCI(bugs, na.rm=TRUE)[2],
            UCLmed = MedianCI(bugs, na.rm=TRUE)[3])
  
  dat <- merged.tibl
  
  ggplot(dat, aes(x = spray, y = bugs, fill = spray)) +
  stat_boxplot(geom ="errorbar", width = 0.5) +
  geom_boxplot(fill = "light blue") + 
  stat_summary(fun.y=mean, geom="point", shape=10, size=3.5, color="black") + 
  ggtitle("Boxplot of Treatments C and D") + 
  theme_bw() + theme(legend.position="none")
  
  #Test each group for normality
dat %>%
  group_by(spray) %>%
  summarise(`W Stat` = shapiro.test(bugs)$statistic,
            p.value = shapiro.test(bugs)$p.value)

#Perform QQ plots by group
ggplot(data = dat, mapping = aes(sample = bugs, color = spray, fill = spray)) +
  stat_qq_band(alpha=0.5, conf=0.95, qtype=1, bandType = "boot") +
  stat_qq_line(identity=TRUE) +
  stat_qq_point(col="black") +
  facet_wrap(~ spray, scales = "free") +
  labs(x = "Theoretical Quantiles", y = "Sample Quantiles") + theme_bw()

#Perform the Mann-Whitney U test
m1<-wilcox.test(bugs ~ spray, data=dat, na.rm=TRUE, paired=FALSE, exact=FALSE, conf.int=TRUE)
print(m1)
 
#Hodges Lehmann Estimator
m1$estimate


```


```{r make-dist}

	# 11 *unique* weeks are expected to satisfy the design of kmPlotNew()
	weeks.list <- getWeeks(bugs.tibl)

	whichData <- bugs.tibl
	# two transects : 'control' and 'oakMargin' (= semi-natural habitat / SNH)
	whichTransect <- 'oakMargin'
	# two trap collection time periods : 'am' and 'pm'
	whichTime <- 'pm'

  SNH.tibl <- whichData %>%
    dplyr::filter(transect==whichTransect)  %>%
    dplyr::filter(time==whichTime) %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::rename(crabSpiders = Thomisidae..crab.spider.)
  # what remains is // row / positionX / crabSpiders / week //

  whichTransect <- 'control'
  
  control.tibl <- whichData %>%
    dplyr::filter(transect==whichTransect)  %>%
    dplyr::filter(time==whichTime) %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::rename(crabSpiders = Thomisidae..crab.spider.) 
  
  ggList <- makeDistributionGraphics(tibbleSNH=SNH.tibl, 
                                     tibbleControl=control.tibl,
                                     time=whichTime)
  
```

```{r dist-graphics}

makeDistributionGraphics <- function(tibbleSNH, tibbleControl, time) {
  
  # ecdf() ?   empirical cumulative distribution function
  # https://bjlkeng.github.io/posts/the-empirical-distribution-function/
  
  # https://rpubs.com/mpfoley73/456645
  # the PDF (probability *density*) and CDF (cumulative distribution) combo graph is
  # extremely confusing. x axes are different (continuous and discrete) and
  # y axes are different (probability per unit and probability)
  # don't overlay them
  
library(ggplot2)
library(dplyr)
options(scipen = 999, digits = 2) # sig digits


eventsSNH <- 0:max(tibbleSNH$crabSpiders)
eventsControl <- 0:max(tibbleControl$crabSpiders)


#  Poisson Distribution
densitySNH <- dpois(x = eventsSNH, lambda = mean(tibbleSNH$crabSpiders))
probSNH <- ppois(q = eventsSNH, lambda = mean(tibbleSNH$crabSpiders), lower.tail = TRUE)
# lambda is a 'rate', the mean number of spiders captured in a time interval
# note : Examples that violate the Poisson assumptions
# https://en.wikipedia.org/wiki/Poisson_distribution
densityControl <- dpois(x = eventsControl, lambda = mean(tibbleControl$crabSpiders))
probControl <- ppois(q = eventsControl, lambda = mean(tibbleControl$crabSpiders), lower.tail = TRUE)

  # a probability mass function is a function that gives the probability that a 
  # discrete random variable is exactly equal to some value.
  # a PMF differs from a probability density function (PDF) in that the latter 
  # is associated with continuous rather than discrete random variables. A PDF 
  # must be integrated over an interval to yield a probability
  # https://en.wikipedia.org/wiki/Probability_mass_function

  tiblSNH <- tibble(events, densitySNH, probSNH)
  tiblControl <- tibble(events, densityControl, probControl) 
  
  captionText <- paste("sampling time: ", time, sep="")

  ggPMF <- ggplot() +
  
    geom_col(data=tiblSNH, aes(x = factor(eventsSNH), y = densitySNH), 
             just = 0, width =.2, fill='green', color='black') +

    #geom_text(data=tiblSNH, aes(x = factor(eventsSNH), y = densitySNH + 0.01, 
                #                label = round(densitySNH, 2)), 
           # size = 3, vjust = 0, nudge_x = -.2 ) +
    
    geom_col(data=tiblControl, aes(x = factor(eventsControl), y = densityControl), 
             just = 1, width =.2, fill='red', color='black') +

    #geom_text(data=tiblControl, aes(x = factor(eventsControl), y = densityControl + 0.01, 
                            #    label = round(densityControl, 2)), 
           # size = 3, vjust = 0, nudge_x = .2 ) +
    
    expand_limits(y = c(0,1)) +

    labs(title = "poisson probability mass function", 
         subtitle = "SNH transect (green), control transect (red)",
         caption = captionText,    
         x = "crab spider counts", y = "probability mass") +
          
    theme_bw()

  ggCDF <- ggplot() +
  
    geom_point(data = tiblSNH, aes(x = factor(eventsSNH), y = probSNH), 
             fill = 'green', shape = 21, size=5) +
    
    geom_segment(data = tiblSNH, aes(x = as.numeric(eventsSNH) + 1, y = probSNH,
                    xend = as.numeric(eventsSNH) + 1.5, yend = probSNH), color = 'black') + 
    
    geom_point(data = tiblControl, aes(x = factor(eventsControl), y = probControl), 
             fill = 'red', shape = 21, size=5) +
    
    geom_segment(data = tiblControl, aes(x = as.numeric(eventsControl) + 1, y = probControl,
                    xend = as.numeric(eventsControl) + 1.5, yend = probControl), color = 'black') +
    
    expand_limits(y = c(.5,1)) +

    labs(title = "poisson cumulative distribution function", 
          subtitle = "SNH transect (green), control transect (red)",
          caption = captionText,
          x = "crab spider counts", y = "cumulative probability") +
  
    theme_bw()

  returnList <- list()
  returnList[[1]] <- ggPMF
  returnList[[2]] <- ggCDF
  
  hostDir <- '/Users/rcphelps/code/thesis/journalArticle/arXiv-preprint'
	where <- paste(hostDir, "/images", sep="")
	filenamePMF <- paste("dist-PMF-", "both", "-", time, "-.png", sep="")
	filenameCDF <- paste("dist-CDF-", "both", "-", time, "-.png", sep="")
	
	saveGraphics(graphics = ggPMF, name = filenamePMF, destinationPath = where) 
	saveGraphics(graphics = ggCDF, name = filenameCDF, destinationPath = where) 
  
  return(returnList)
}

```


```{r make-clusters}


	
	# 11 *unique* weeks are expected to satisfy the design of kmPlotNew()
	weeks.list <- getWeeks(bugs.tibl)


	
	whichData <- bugs.tibl
	# two transects : 'control' and 'oakMargin' (= semi-natural habitat / SNH)
	whichTransect <- 'oakMargin'
	# two trap collection time periods : 'am' and 'pm'
	whichTime <- 'pm'

	clusters.list <- list()
	clusters.tibl <- tibble::tibble('defaultColumn', .rows = 10)
	
		for (i in 1:length(weeks.list)) {

			  # currentWeek <- weeks.list[[i]]
        temp.tibl <- assignClusters(week=weeks.list[[i]], transect = whichTransect,
                                 time=whichTime, tibble=whichData, debug=FALSE)

        clusters.tibl <- dplyr::bind_cols(clusters.tibl, temp.tibl)
                                          
		  }
	
	# cleanup
	# set cluster integers to 'factors' so that ggplot
	# 'fill' will be determined by the integer value
	clusters.tibl <- clusters.tibl %>%
	                 dplyr::select(-'"defaultColumn"') %>%
	                 dplyr::mutate_all(as.factor) %>%
	                 dplyr::mutate(position=row_number()) 
	

  
	gg <- kmPlotNew(tibble = clusters.tibl, transectText = whichTransect, timeText = whichTime)
	
	hostDir <- '/Users/rcphelps/code/thesis/journalArticle/arXiv-preprint'
	where <- paste(hostDir, "/images", sep="")
	filename <- paste("clusters-", whichTransect, "-", whichTime, "-.png", sep="")
	
	saveGraphics(graphics = gg, name = filename, destinationPath = where) 
  
	  
	  
```


```{r general}

saveGraphics <- function(graphics, name, destinationPath) {
  
      # gg : ggplot output
      # name : filename with extension ('pdf')
      # dirPath : path to host directory relative to working directory
  
  
      # setwd("/Users/rcphelps/code/avo-soil-leaf-data/")
      # fileName <- paste("NK", "-monthly.pdf", sep="")
      # dirPath <- paste(wd, "/output", sep="")
  
      fullPath <- paste(destinationPath, "/", name, sep="")

      if (file.exists(fullPath)) { file.remove(fullPath) }

        # device not necessary if extension provided
      suppressMessages(ggsave(name, plot = graphics, device = NULL, 
                              path = destinationPath,
                              scale = 1, width = 3.8, height = 4, 
                              dpi = 300, limitsize = TRUE, units = "in") )
      
      if (file.exists(fullPath)) { 
        return(paste( "saved ", fullPath, sep=" "))
      }
      else {
        return(paste( "unable to save ", fullPath, sep=" "))
      }
      
}

```



```{r}


kmPlotNew <- function(tibble, transectText, timeText) {

	# build a plot that represents weekly clusters (1:3) by vineyard 
  # position (1:10)
  #
  # this result will be used to assess cluster position 'boundaries' 
  # that may appear as samples are taken from the vineyard edge 
  #
  # tibble : columns are "week23" "week24" ... "week32" and "position"
  #          rows are weekly cluster assignments as factors (1:3) 
  #          and row position as character (1:10) (there are 10 rows)
  #
  # weeks : a list, chr[1:10] "week23" "week24" ... "week34"
  # transectText :  text for informational subtitle content
  # timeText : text for informational subtitle content indicating 'am' or 'pm'
  
  if (transectText == 'oakMargin') {
    # adjust for source data ambiguity
    transectText <- 'SNH'
  }
  
  captionText <- paste("crab spider clusters\n", 
                       "transect: ", transectText, "\ndaytime: ", timeText, sep="")
  
  # get a list of the week labels ('weekXX')
  weeks <- colnames(tibble)
  # get a list of week IDs ('integers')
  weekID.list <- disectWeeks(w=weeks)
  
  
  clusterColors = c("3" = "blue", "2" = "green", "1" = "red", "0" = '#FFFFFF')

	gg <- ggplot(data = tibble) + 

  	      geom_point(aes(y = position, x = weeks[[1]], fill = week23),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[2]], fill = week24),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[3]], fill = week25),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[4]], fill = week26),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[5]], fill = week27),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[6]], fill = week28),  
  		         shape = 21, size=5) +
	  
  	      geom_point(aes(y = position, x = weeks[[7]], fill = week29),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[8]], fill = week30),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[9]], fill = week31),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[10]], fill = week32),  
  		         shape = 21, size=5) +
	  
	        geom_point(aes(y = position, x = weeks[[11]], fill = week34),  
  		         shape = 21, size=5) +

	        scale_fill_manual(values = clusterColors, 
	                    limits = names(clusterColors),
	                    labels = c("cluster 3", "cluster 2", "cluster 1")) +
	
    expand_limits(y=c(1,10)) +
    scale_y_continuous(breaks = seq(min(1), max(10), by = 1)) +
	  
	  scale_x_discrete(breaks=weeks, labels=weekID.list) +
    #expand_limits(x=c(22,34)) +    # enlarge the range of the axis
    #scale_x_discrete(breaks=seq(22,34,2)) +         # log, square-root, reverse....

    geom_hline(yintercept=5.5) +
    geom_hline(yintercept=8.5) +

    coord_fixed(ratio=1) + # control the aspect ratio

    labs(x="week number", y="trap position", caption = captionText ) +

  	theme_bw() +
    
	  # axis.title.x=element_text(angle=45, vjust=0.5),
	  # axis.text = element_text(colour = 1, size = 12),
	  #     legend.spacing.y = unit(0, "mm"), 
	  #     legend.title = element_blank(),
    #     legend.justification=c(1,0),
    #     legend.background = element_blank(),
    #     legend.box.background = element_rect(colour = "black")
    #     guide_legend(title="clusters") +
    #     guides(fill=guide_legend(title="clusters")) +
	  #     aspect.ratio = 1, 
	  
    theme(
          axis.text.x = element_text(angle = 45),
          panel.border = element_rect(colour = "black", fill=NA),
          legend.position="bottom",
          legend.title = element_blank()
          ) 
	
	return(gg)

}

```


```{r cluster-functions}

getWeeks <- function(data) {
  
  # get a vector of weeks found in the tibble of bugs
  
	weeks.vector <- data %>%
   					select(week) %>%
   					unique() %>%
   					.$week

  return(weeks.vector)
	
}

disectWeeks <- function(w) {
  
  # get a vector of weeks by chopping the list of week labels
  # 
  
  weeks.vector <- list()

		for (i in 1:length(w)) {

		  currentWeek <- substring(w[[i]], 5, 6)
      weeks.vector[[i]] <- currentWeek
                               
		  }

  return(weeks.vector)
	
}

enoughData <- function(tibble, debug) {
  
  # check to see if there is enough data (non-zero spider counts)
  # to assign 3 clusters with kmeans() 
  
  # tibble input: for a specific week, spider counts for each positionX
  #
  #  week   positionX   crabSpiders
  
  
  
#             non-zero (of 11) weekly positional spider counts
#           (if count < 2,  clusters of 3 cannot be generated)
#
#  week  'oakMargin'+'am'  'oakMargin'+'pm' 'control'+'am' 'control'+'pm'
#         
#   23         5               10                8             11
#   24        11               11               11             11
#   25         9                9               10             10
#   26         9                9                7              9        
#   27         6                6                4              5
#   28         9               10                7              8
#   29         6                9                8              6
#   30         6                4                7              8
#   31         4                6                7              4
#   32         3                6                5              4
#   34         1                2                2              4

# code to generate the table above (this is the template for enoughData() )
if (FALSE) {
  zero.tibl <- bugs.tibl %>%
    dplyr::filter(transect=='oakMargin')  %>%
    dplyr::filter(time=='am') %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::group_by(week, positionX) %>%
    dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep')

  nonZeroPositions <- list()
  for (i in 1:length(weeks.list)) {
     zeroPositions <- zero.tibl %>% 
      filter(week==weeks.list[[i]] & crabSpiders == 0) %>% nrow()
    nonZeroPositions[[i]] <- 11 - zeroPositions
  }
  print(nonZeroPositions)
}
  
    zeroCounts <- tibble %>% filter(crabSpiders == 0) %>% nrow()

    if (zeroCounts > 9) {
      return(FALSE)
    }
    else {
      return(TRUE)
    }
}

assignClusters <- function(week, transect, time, tibble, debug) {
  
  # rationalize cluster assignments by week such that clusters
  # across multiple weeks can be visually compared
  
  # params :
  # week (discovered by utility function getWeeks()), 
  # transect (either 'control' or 'oakMargin')
  # time (either 'am' or 'pm')
  # tibl : this is the raw (all weeks, both clusters) tibble of all crab spiders
  # debug : (TRUE or FALSE for manual cluster list examination)
  
  # return: a list of 10 integers; values 1, 2, or 3 representing
  # updated cluster assignments
  
  # testing
  # > testParams(week=28, transect='control', tibl=bugs.tibl, debug=TRUE)
  # [1] "original clusters : 3 3 3 3 3 1 1 2 1 1"
  # [1] "revised clusters : 1 1 1 1 1 2 2 2 3 3"
  
  # based on examination of the spider counts for the season
  # I propose that there are 3 distinct clusters each week
  #
  # for positions 1-2-3 (expected typical cluster ID is '1')
  # and for positions 8-9-10 (expected typical cluster ID is '3')
  # kmeans() won't guarantee that they are structured this way,
  # (3s or 2s could be assigned at the beginning, and 1s or 2s at the end.)
  # this function tries to normalize these vectors so patterns 
  # between weeks can be compared.
  
  # kmeans() wants to evaluate groups of points specified in x,y coordinates
  # and assign them to clusters. 
  
  # the kmeans() return object encapsulates numerous params including 
  # 'cluster' (an arbitrary ID) ranked high-to-low or low-to-high.
  # so, to compare clusters across weeks, we need to re-assign cluster IDs
  # based on consistent ranks.
  
  # logic to enable cluster comparison across weeks:
  #
  # check cluster assignments for positions 1-2-3,  4-5-6, 8-9-10
  # I propose that positions 1-2-3 will likely be in the same cluster
  # as will positions 8-9-10. for a week's clusters assigned by kmeans() like                             
  # position              1 2 3 4 5 6 7 8 9 10
  # cluster assignment    3 1 1 x x x x 1 2 2
  
  # this function should notice that 3's should be 2's
  # and vice versa. It does not matter that the ranking criteria 'match' or 
  # 'align' from one week to another. Organizing ranks such that '1s' tend to be
  # at the beginning of the vineyard row and '3s' tend to be at the end of
  # the row will make a graphical comparison of clusters across weeks
  # easier 
  
  # for positions 1-2-3 (expected typical cluster ID is '1')
  # if "no matches" then no cluster assignment changes
  # if at least 2 matches of '1', then no cluster assignment changes
  # if at least 2 matches of '3', 
  #                             change every instance (for all positions) of '3' to '1', 
  #                             change every previous instance of '1' to '3'
  # if at least 2 matches of '2', 
  #                             change every instance (for all positions) of '2' to '1', 
  #                             change every previous instance of '1' to '2'
  # 
  # for positions 8-9-10 (expected typical cluster ID is '3')
  # if "no matches" then no cluster assignment changes
  # if at least 2 matches of '3', then no cluster assignment changes
  # if at least 2 matches of '2', 
  #                             change every instance (for all positions) of '2' to '3', 
  #                             change every previous instance of '3' to '2'
  # if at least 2 matches of '1', then no changes (this probably means that the clusters 
  # are totally scrambled)
  # 
  # note that this logic breaks if the true cluster for both groups 1-2-3 and 
  # 8-9-10 is '1' or '3' (very unlikely)
  # also, it does not correct 
  # position              1 2 3 4 5 6 7 8 9 10
  # cluster assignment    2 2 2 1 1 1 1 3 3 3
  # (this outcome is possible.....)

  # allow all data to be specified
  if (time == 'am' | time == 'pm') {
    bugsByWeek.tibl <- tibble %>%
      dplyr::filter(transect=={{transect}})  %>%
      dplyr::filter(time=={{time}}) %>%
      dplyr::select(-transect, -position, -date, -time, -julian) %>%
      dplyr::group_by(week, positionX) %>%
      dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep'  )
  }
  else {
    bugsByWeek.tibl <- tibble %>%
      dplyr::filter(transect=={{transect}})  %>%
      dplyr::select(-transect, -position, -date, -time, -julian) %>%
      dplyr::group_by(week, positionX) %>%
      dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep'  )
  }
  
  if (FALSE) {
  bugs.tibl %>%
    dplyr::filter(transect=='control')  %>%
    dplyr::filter(time=='pm') %>%
    dplyr::select(-transect, -position, -date, -time, -julian) %>%
    dplyr::group_by(week, positionX) %>%
    dplyr::summarize(crabSpiders=sum(Thomisidae..crab.spider.), .groups='keep')
  }

  # the result is, for each positionX in each week, crabSpider counts are   calculated
  #
  #  week   positionX   crabSpiders

  # isolate the week's data
  week.tibl <- bugsByWeek.tibl %>%
                  dplyr::filter(week=={{week}}) %>%
                  ungroup() %>% dplyr::select(-week)
  
  # verify that there is enough data to make 3 clusters
  if (enoughData(tibble=week.tibl, debug=debug) == TRUE) {
    
    # build the clusters
  
    # note: base::scale() is used to ensure that the original x (spider counts)
    # and y (trap position) axis scales do not skew the cluster assessment
    scaled.tibl <- as_tibble(scale(week.tibl))

    set.seed(20)

    clusters.kmeans <- scaled.tibl %>% 
      dplyr::select(positionX, crabSpiders) %>% 
      kmeans(centers = 3, iter.max = 500, nstart = 3)


    # get the cluster vector
    original.cluster.list <- clusters.kmeans$cluster

    # create lists capturing the original positions of 1, 2, and 3
    ones.list <- replace(original.cluster.list, original.cluster.list != 1, 0)
    twos.list <- replace(original.cluster.list, original.cluster.list != 2, 0)
    threes.list <- replace(original.cluster.list, original.cluster.list != 3, 0)
    # ones.list + twos.list + threes.list = original.scan.list
    orig.ones.list <- ones.list
    orig.twos.list <- twos.list
    orig.threes.list <- threes.list

    # are there at least 2 matches of '3' in position 1-2-3 ?
    if (sum(orig.threes.list[1:3]) > 3) {
      # there are multiple 3s in the first 3 positions, swap 3s to all 1s
      ones.list <- replace(orig.threes.list, orig.threes.list==3, 1)
      twos.list <- replace(orig.twos.list, orig.twos.list==2, 2)
      threes.list <- replace(orig.ones.list, orig.ones.list==1, 3)
    # are there at least 2 matches of '2' in position 1-2-3 ?  
    } else if (sum(orig.twos.list[1:3] == 2) > 2) {
      # there are multiple 2s in the first 3 positions, change all 2s to 1s
      ones.list <- replace(orig.twos.list, orig.twos.list==2, 1)
      twos.list <- replace(orig.ones.list, orig.ones.list==1, 2)
      threes.list <- replace(orig.threes.list, orig.threes.list==3, 3)
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    revised.ones.list <- ones.list
    revised.twos.list <- twos.list
    revised.threes.list <- threes.list

    if (debug==TRUE) {
      print("original")
      print(orig.ones.list)
      print(orig.twos.list)
      print(orig.threes.list)
      print(original.cluster.list)

      print("before 8:10")
      print(" ")
      print(revised.ones.list)
      print(revised.twos.list)
      print(revised.threes.list)
      print(revised.scan.list)
    }

  
    # are there at least 2 matches of '2' in position 8-9-10 ?
    if (sum(revised.twos.list[8:10]) > 2) {
      # there are multiple 2s in the last 3 positions, swap 2s to all 3s
      twos.list <- replace(revised.threes.list, revised.threes.list==3, 2)
      threes.list <- replace(revised.twos.list, revised.twos.list==2, 3)
      ones.list <- replace(revised.ones.list, revised.ones.list==1, 1)
    # are there at least 2 matches of '1' in position 8-9-10 ?  
    } else if (sum(revised.ones.list[8:10]) > 1) {
      # there are multiple 1s in the last 3 positions, change all 1s to 3s
      threes.list <- replace(revised.ones.list, revised.ones.list==1, 3)
      twos.list <- replace(revised.twos.list, revised.twos.list==2, 2)
      ones.list <- replace(revised.threes.list, revised.threes.list==3, 1)
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    revised.ones.list <- ones.list
    revised.twos.list <- twos.list
    revised.threes.list <- threes.list
  
    if (debug==TRUE) {
      print("after 8:10")
      print(" ")
      print(ones.list)
      print(twos.list)
      print(threes.list)
      print(revised.scan.list)
    }
  
    # two final rules
    # position 1 should always be assigned to cluster 1
    # position 10 should always be assigned to cluster 3
    # handling only the situation where a 2 exists in either position
    # (not both)
  
    # is there a '2' in position 1 ?
    if (revised.scan.list[1] == 2) {
      # change all 2s to 1s and 1s to 2s
      ones.list <- replace(revised.twos.list, revised.twos.list==2, 1)
      twos.list <- replace(revised.ones.list, revised.ones.list==1, 2) 
      threes.list <- revised.threes.list
    } 
    # is there a '2' in position 10 ? 
    if (revised.scan.list[10] == 2) {
     # change all 2s to 3s and 3s to 2s
      threes.list <- replace(revised.twos.list, revised.twos.list==2, 3)
      twos.list <- replace(revised.threes.list, revised.threes.list==3, 2) 
      ones.list <- revised.ones.list
    } 

    revised.scan.list <- ones.list + twos.list + threes.list
    
  }
  else {
    # enoughData() returned FALSE, not enough data to build clusters
    # set the revised scan list to zeros (no clusters assigned)
    original.cluster.list <- c(0,0,0,0,0,0,0,0,0,0)
    revised.scan.list <- c(0,0,0,0,0,0,0,0,0,0)
  }
  
  if (debug==TRUE) {
      print(paste("week : ", week, sep=''))
      printString <- paste("original clusters : ",
                         do.call("paste",
                                as.list(original.cluster.list)), sep='')
      print(printString)
      printString <- paste("revised clusters : ", 
                         do.call("paste", 
                                 as.list(revised.scan.list)), sep='')
      print(printString)
    }
  

  # return the cluster assignments as a single column tibble
  #
  revised.scan.list.tibl <- as_tibble(revised.scan.list)
  # default column name is 'value'
  # this is a dplyr hack to specify the column name
  # https://stackoverflow.com/questions/45472480/how-to-rename-a-column-to-a-variable-name-in-a-tidyverse-way
  colName <- as.name(paste("week", week, sep=''))
  revised.scan.list.tibl <- revised.scan.list.tibl %>%
                              dplyr::rename(!!colName := value)
  
  return(revised.scan.list.tibl)

}
	
```

